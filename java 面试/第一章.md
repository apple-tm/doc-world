# 第一章



#### 面向对象

1. 与面向过程的区别：注重**参与者（对象）**、及各自需要做什么，注重**步骤**和**顺序**
2. 举例：洗衣机洗衣服
   1. 过程：打开洗衣机、放衣服、放洗衣粉、清洗、烘干
   2. 对象：
      1. 人：打开洗衣机、放衣服、放洗衣粉
      2. 洗衣机：清洗、烘干
3. 优点：易于复用、维护和扩展
4. 三大特性
   1. 封装:隐藏对象属性和方法实现细节
      1. java bean：属性私有，属性赋值和获取逻辑只能有 java bean 本身决定，不能有外部修改，可以提供对象保护
      2. orm：封装 JDBC，不需要关系数据库连接如何获取、SQL 如何执行，直接调用接口
      3. 修改自己的实现代码，而不用修改那些调用我们代码的程序片段
   2. 继承
      1. 子类共性的方法直接使用父类的
      2. 代码可复用
      3. 子类重写父类的方法可扩展
   3. 多态
      1. 继承+重写+父类引用执行子类对象
      2. 外部对同一个方法的调用，实际执行的逻辑依赖具体实现类
      3. 执行时更具对象的实际类型调用相应的方法
      4. 同一个事件发生在不同的对象上会产生不同的结果，飞机和鸟都能飞，但是具体怎么飞是不同的



#### ==和 equals

1. == 比较的是 stack 中的值，基本数据类型是变量值，引用数据类型比较的是对象内存地址的值

2. equals 是 Object 的方法, 没有重写和==功能一致

   ```java
   public boolean equals(Object obj) {
   	return (this == obj)；
   }
   ```

3. String 的 equals 实现
   1. 比较引用地址，相等返回 true，同一个对象
   2. 判读比较的类型，非  instanceof String 返回 false
   3. 比较 length，不相等返回 false
   4. 依次比较每个 char，全部相等返回 true，否则返回 false
4. equals 和==默认比较对象是否是同一个对象
5. equals 重写后大多按属性内容是否一致判断，但比较内存地址最好作为前置条件



#### final

1. 修饰类，不能被继承，String
2. 修饰方法，不能被重写，可以重载
3. 修饰变量
   1. 成员变量：
   2. 局部变量
      1. 必须显示初始化，不会有默认值，在使用局部变量之前一定要赋初值
4. 修饰基本数据类型，初始化之后值不能修改，此为常量
5. 修饰引用数据类型，引用不能再指向其他对象，其实道理和基本数据类型一样，其他对象的地址肯定不相同，当然引用指向的对象的内容可修改
6. 为什么局部内部类和匿名内部类只能访问局部 final变量
   1. 匿名内部类
      1. 比如一个方法中开启一个线程，方法执行完，但线程有自己独立的生命周期，线程使用的局部变量会因为外部方法执行完而回收，导致不和逻辑的问题
      2. 将局部变量复制为内部类变量时，必须保证这两个变量是一样的
      3. 这也是为什么 lamda 表达式中的变量要求 final 修饰
   2. 注意：一个内部类会导致类类文件数+1
   3. 内部类中引用局部变量会 隐示复制为内部类的成员变量，但要保证值的一致性，变量必须有 final 修饰

#### StringBuilder,StringBuffer，String

1. 性能 依次降低

2. 修改字符串优先使用StringBuilder，多线程共享变量时使用 StringBuffer

3. 为什么 String 不可变

   1. 多线程共享安全

   2. String 创建时可以缓存其属性 hashCode,所以 String 适合做 HashMap 的 key，因为无需每次 push 都计算 hashCode

   3. 可实现字符串池，每个字符串只存一次

   4. 用户名、密码等字符串如果可变，导致安全问题

      ```java
      　String s1 = "AB"+"C";
      
      　String s2 = "A"+"BC";
      　// 也许很多新手都会觉得不是指向同一个对象，但是考虑到现代编译器会进行常规的优化所以他们都会指向常量池中的同一个对象。
      
      　
      ```

      

#### 重写和重载

1. 重写
   1. 发生在父子类
   2. 方法名和参数列表必须相同
   3. 返回值范围小于等于父类
   4. 异常范围小于等于父类，使用父类引用指向子类对象时，参数传递后，并不知道子类具体类型
   5. 访问修饰范围大于等于父类，如果小于，多态父类引用指向子类对象无法使用了
   6. private的方法无法重写，外部无法访问
   7. final 方法无法重写
2. 重载
   1. 发生同一个类中
   2. 方法名相同
   3. 参数类型、个数、顺序不同
   4. 方法返回值和访问修饰符可以不同



#### 接口和抽象类

1. 抽象类存在普通成员方法，接口方法默认 public abstract，变量必须是public、static、final，JDK8及以后，允许我们在接口中定义static方法和default方法。

   ```java
   public interface JDK8Interface {  
     
       // static修饰符定义静态方法  
       static void staticMethod() {  
           System.out.println("接口中的静态方法");  
       }  
     
       // default修饰符定义默认方法  
       default void defaultMethod() {  
           System.out.println("接口中的默认方法");  
       }  
   }  
   
   public class JDK8InterfaceImpl implements JDK8Interface {  
       //实现接口后，因为默认方法不是抽象方法，所以可以不重写，但是如果开发需要，也可以重写  
   }  
   
   public class Main {  
       public static void main(String[] args) {  
           // static方法必须通过接口类调用  
           JDK8Interface.staticMethod();  
     
           //default方法必须通过实现类的对象调用  
           new JDK8InterfaceImpl().defaultMethod();  
       }  
   }  
   
   ```

2. 接口约束行为的有无，但不对如何实现行为进行限制，like a 模式
3. 抽象类为了代码复用，is a模式，包含并实现子类通用特性，不能实例化，存在没有实现的方法，实例化后调用存在逻辑问题
4. 关注事物本质使用抽象类，关注一个操作使用接口



#### List 和 Set 接口

1. list
   1. 有序，按 insert 插入顺序排序，
   2. 元素可重复，可 null
   3. 使用 Iterator接口访问
   4. 可以使用 get 随机访问
2. set
   1. 无序
   2. 不可重复
   3. 最多一个 null，不可重复嘛
   4. 只能使用 Iterator 访问



#### hashCode 和 equals

1. hashCode
   1. 获取 Hash 码，返回一个 int 值
   2. int 值就是对象在哈希表中的下标索引
   3. 对象在哈希表中的下标索引就是 Hash 码
   4. 特点：通过 key 快速检索到对应的值，中间使用 hash 码快速定位，吊啊
2. equals
   1. HashSet如何检测重复？
   2. 先计算对象的 hashCode值获取对象的 hash码,哈希表索引，看是否有值，没有就任务没有出现
   3. 如果有再使用 equals检测对象是否相等
   4. hashCode 模式大大减少了对比次数，提升了性能