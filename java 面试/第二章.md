# 第二章



#### ArrayList and LinkedList

1. ArrayList
   1. 基于动态数组
   2. 内存连续
   3. 随机访问、下标访问
   4. 性能：尾插法并且指定数组初始容量可以提升性能
2. LinkedList
   1. 基于链表
   2. 内存分散
   3. 适合插入和删除
   4. 遍历需从头、从尾遍历
   5. 需要创建大量 Node 对象，损耗性能



#### HashMap and HashTable

1. HashMap
   1. 基于数组、链表、红黑树
   2. 链表长度到 8 并且数组长度超过 64，链表转为红黑树
   3. 元素以 Node节点存在
   4. 计算key 的 Hash 值，二次 Hash然后对数组取模得到对应数组的下标
   5. 如果没有 Hash 冲突，则创建 Node 对象存入
   6. 如果产生 Hash 冲突，则使用 equals 比较，相同则取代
   7. 不同判断链表高度是否到 8，到就转为红黑树（数组长度超过 64），红黑树长度低于 6 又转为链表
   8. key 为 null 的存在下标 为 0 的地方
   9. 线程不安全
   10. key 、value 可以为 null
2. HashTable
   1. 线程安全
   2. key，value 不能为 null



#### ConcurrentHashMap

1. jdk7
   1. 基于ReentrantLock、Segment、HashEntry(一个链表结构)
   2. 元素查询，一次 Hash 定位到HashEntry所在Segment，二次 Hash 定位到元素所在 HashEntry 的头部
   3. 锁：segment 分段锁，segment 继承 ReentrantLock,锁定segment，所以并发度为 segment 数
   4. get 无需加锁，volatile 保障
2. jdk8
   1. Synchrozied\CAS\Node
   2. 查找、替换、赋值都是用 CAS乐观锁
   3. CAS：预期值、内存值、要修改的值，只有预期值和内存值相等才把内存值修改为要修改的值，如果不等，说明其他线程修改了内存值，导致的并发问题，所以重试，直到成功

#### IOC 容器

1. 配置文件中指定包扫描路径
2. 定义一些注解，分别表示控制层，业务层、依赖注入、获取配置文件
3. 从配置文件中获取包扫描路径，将其下的.class 文件加入到一个 set 集合
4. 遍历 set 集合，获取类上的注解，反射创建对象，交给IOC 容器，使用线程安全的 Map 集合存储
5. 遍历容器，进行递归注入



#### 字节码

1. 扩展名为.class 的文件
2. 面向虚拟机，各个 OS 的机器指令不尽相同，不同平台的 JVM 解释器把字节码解释成不同平台对应的指令



#### 类加载器

1. 启动类加载器(Bootstrap Classloader)：<JAVA_HOME>/lib目录下并且被虚拟机识别的类库加载到虚拟机内存中。我们常用基础库，例如java.util.**，java.io.**，java.lang.**等等都是由根加载器加载。
2. 扩展类加载器(Extention Classloader)负责加载JVM扩展类：比如swing系列、内置的js引擎、xml解析器等，这些类库以javax开头，它们的jar包位于<JAVA_HOME>/lib/ext目录中
3. 应用程序加载器(Application Classloader)也叫系统类加载器：负责加载用户路径(ClassPath)上所指定的类库。
4. 自定义加载器：extends ClassLoader



#### 双亲委托模型

1. 当某个类加载器需要加载某个`.class`文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。
2. 防止重复加载同一个`.class`。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全
3. 保证核心`.class`不能被篡改。通过委托方式，不会去篡改核心`.clas`，即使篡改也不会去加载，即使加载也不会是同一个`.class`对象了。不同的加载器加载同一个`.class`也不是同一个`Class`对象。这样保证了`Class`执行安全。
4. 全路径+类加载器才能确定是一个唯一的类，相同的类被不同的类加载器加载就是不同的类，双亲委托模型避免了重复加载



#### 异常体系

1. 顶级父类：Throwable
2. 顶级父类的两个子类为 Error 和 Exception
3. Error 程序无法处理，一旦出现，程序被迫 showdown
4. Exception 不会导致程序停止，分为 RuntimeException 和 CheckedException（编译过程检测）
5. RuntimeException 会导致当前线程执行失败，开发主要处理的异常



#### GC 判断对象是否该回收

1. java 使用可达性分析算法
2. GC roots 向下搜索，一个对象到GC roots没有任何引用链时，说明该对象不可达，是游离的无用对象，可回收
3. 引用计数法，每个对象有一个引用计数器，新增一个引用+1，引用释放-1，为 0标识可以回收
4. 引用计数器问题，A、B 对象相互引用，引用计数器不会降为 0，导致无法回收‘



#### 线程生命周期、线程状态

1. 五种状态：创建、就绪、运行、阻塞和死亡
2. 阻塞分三种
   1. 等待阻塞：运行线程执行 wait,线程释放资源，被放入对象等待池，不能自动唤醒，需要依靠其他线程执行该对象的 notify唤醒线程
   2. 同步阻塞：运行线程获得同步锁时，锁被其他线程占用，线程会被放入锁池中，典型的 synchronized，这其实也是等待阻塞，只不过获得锁的线程执行完方法会自动释放锁，锁池线程就开始进入就绪状态竞争 CPU
   3. 其他阻塞：线程执行了 sleep、join、IO请求，sleep 超时、IO 结束，线程重新进入就绪状态（IO 会导致线程阻塞）

