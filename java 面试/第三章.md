# 第三章



#### sleep、wait、join、yield

1. 锁池：竞争同步锁的线程会放到锁池
2. wait：线程会进入等待池，notify 随机释放一个线程，如果线程处于同步锁机制中就会进入锁池，否则直接进入就绪态
3. sleep 是 Thread 的静态本地方法，wait 是 Object的本地方法
4. sleep 不会释放锁，同步机制下，非同步机制无需获得锁，就没有释放锁之说
5. sleep 不依赖同步机制，wait 依赖 synchronized 机制
6. sleep 不需要被唤醒，wait 需要
7. sleep 用于线程休眠，轮询，wait 用于线程间通信
8. sleep会让出 CPU并且强制上下文切换，wait 不一定，wait 后可能被马上唤醒
9. yield 让步，执行后直接让线程进入就绪状态，如果在运行，马上放弃 CPU
10. join：线程 B 执行了线程 A.join，线程 B 进入阻塞直到线程 A 执行完，相当于执行 join 的线程加入到调用 join 的线程之后执行



#### 线程安全

1. 堆的对象线程共享
2. 栈：每个线程独有，OS 切换线程时自动切换栈
3. 多个线程访问同一个对象，如果不进行同步机制的情况下调用对象的方法都能获得正确的结果，称这个对象是线程安全的



#### Thread 、Runable

1. Thread 是线程类，Runable 是可运行线程对象
2. Runable 可以将线程的实现和线程执行的业务解耦
3. Runable 实现类对象作为参数传入 Thread 构造方法才能使用



#### 守护线程

1. 是所有非守护线程的守护线程，对所有非守护线程服务
2. 非守护线程都执行完，守护线程自动挂掉
3. 生命周期不可控，所以IO、file 操作不要分配给守护线程
4. 作用：GC 线程
5. 运行中的线程不能设置为守护线程
6. java ExecutorService会将守护线程转为用户线程



#### ThreadLocal

1. 线程间数据隔离
2. 对象跨层传递时，可以避免多次传递，打破层次 间的约束
3. 事务控制，存储线程事务信息
4. 数据库连接、session会话管理等
5. spring事务管理默认给当前线程绑定一个 JDBC Connection，事务过程中都是使用线程绑定的Connection，实现事务的隔离性，使用了 ThreadLocal
6. 数据同步，并发量大时，不使用事务