# JVM

#### 目的

1. 减少 full GC 次数
2. 减少 full GC 时间
3. GC 线程工作时会停掉用户线程导致用户响应延迟、卡顿（重点），称为 STW （stop the world）机制
4. 为什么需要 STW 机制，反证法，如果用户线程和 GC 线程同时执行，当一个线程执行完，它的 GC root 消失了，导致其引用的对象链变成游离垃圾，导致线程共享的堆内存变成线程私有了，所以必须有 STW 机制，在多线程环境下保障线程共享对象的生命周期正确

#### 内存图

![JVM 内存](/Users/apple/Documents/git/doc-world/附件/JVM 内存.png)

1. main 方法栈帧最先进入内存最后 clear，FILO 先进后出，所以使用 stack 作为方法执行模型

2. 操作数栈：代码中的计算逻辑在这里执行结果存在局部（本地）变量表中

3. 动态链接：执行方法时，需要通过方法、对象的引用地址找到实际地址，以便执行

4. 字节码执行引擎

   1. GC：垃圾对象回收线程

   2. minor GC 对年轻代内存区域做垃圾回收

   3. GC 原理：可达性分析，分析引用链上所有的对象标记为非垃圾存储到幸存者区

      1. 第一次伊甸园满：从 GC root 节点可达性分析，将非垃圾复制到幸存者区1（分代 1），清空伊甸园垃圾

      2. 第二次伊甸园满：可达性分析，将非垃圾（幸存者区1+伊甸园）复制到幸存者区2（幸存者区1的对象变为分代 2，伊甸园的为分代 1），清空伊甸园和幸存者区1

      3. 第三次，重复第一次的流程

      4. 当对象的分代变为 15 代会复制到老年代

         ![GC](/Users/apple/Documents/git/doc-world/附件/GC.png)

   4. 一个对象没有指针指向就是游离的对象，是垃圾（无用对象）





#### 字节码

1. javap -c xxx.class > xxx.txt 生成可视化java字节码

2. 字节码中使用的 jvm 指令集可以参考官方文档，以便读懂字节码

3. 代码执行过程

   ```java
   int a = 1;
   int b = 2;
   int c = (a + b) * 10;
   return c;
   ```

   ![字节码执行流程](/Users/apple/Documents/git/doc-world/附件/字节码执行流程.png)

   1. 指令集
      1. const系列：简单的数值类型送到栈顶
      2. push系列：把一个整形数字（长度比较小）送到到栈顶
         1. bipush 将单字节的常量值(-128~127)推送至栈顶
         2. sipush 将一个短整型常量值(-32768~32767)推送至栈顶
      3. ldc系列
         1. 数值常量或String常量值从常量池中推送至栈顶
         2. 对于const系列命令和push系列命令操作范围之外的数值类型常量，都放在常量池中
         3. 所有不是通过new创建的String都是放在常量池中的
      4. load系列
         1. 把本地变量的送到栈顶。这里的本地变量不仅可以是数值类型，还可以是引用类型。
         2. aload_0 //将this引用推送至栈
         3. iconst_0 //数组的索引值（下标）推至栈顶，即压入栈
      5. store系列
         1. 把栈顶的值存入本地变量

#### 线程计数器

1. CPU 线程切换时方便还原线程执行环境，就是线程执行到那段代码了
2. 线程隔离，一个线程一个程序计数器



#### GC 分析工具

#### jvisualvm 命令启动



#### 机器内存估算

![点击量估算](/Users/apple/Documents/git/doc-world/附件/点击量估算.png)





![估算虚拟机参数](/Users/apple/Documents/git/doc-world/附件/估算虚拟机参数.png)



#### 对象动态年龄判断机制

1. 放入幸存者区的一匹对象内存大于等于 50%幸存者区内存时触发
2. 会将这批对象中年龄待最大的对象及其其他大于等于该年龄的对象放入老年代，就是不满 15 代也会放入老年代
3. 会导致老年代快速变大，导致 FULL GC



#### FULL GC 优化

扩大年轻代, 避免对象动态年龄判断机制的触发