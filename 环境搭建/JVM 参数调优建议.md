

# JVM

| 参数名             | 含义                    | 建议值             | 备注                                                         |
| ------------------ | ----------------------- | ------------------ | ------------------------------------------------------------ |
| -Xms               | 初始堆大小              | 物理内存的 60%~80% | 设置与最大堆相同，避免GC 导致JVM 虚拟机重新分配内存          |
| -Xmx               | 最大堆大小              | 物理内存的 60%~80% | =年轻代+年老代+持久代（java8 被移动到本地内存的元空间，class 类） |
| -Xmn               | 年轻代大小              | Xmx的 25%          | 表示年老代占 75%，Sun 官方推荐 3/8                           |
| -XX：MetaspaceSize | jdk8 后                 | 96m                | 堆外内存、本地内存（线程共享）                               |
| -XX:SurvivorRatio  | Eden 与 Survivor 的比值 | 8                  | 年轻代包含一个伊甸园区和两个幸存者区，伊甸园区：幸存者区=8：2，一个 Survivor 占年轻代的 1/10，伊甸园区中被 GC KILL 的对象很多 |
|                    |                         |                    |                                                              |
|                    |                         |                    |                                                              |
|                    |                         |                    |                                                              |
|                    |                         |                    |                                                              |



#### jvm 分代策略

JVM在程序运行过程当中，会创建大量的对象，这些对象，**大部分是短周期的对象**，小部分是长周期的对象，对于短周期的对象，需要**频繁地进行垃圾回收以保证无用对象尽早被释放掉**，对于长周期对象，则不需要频率垃圾回收以确保无谓地垃圾扫描检测。为解决这种矛盾，Sun JVM的内存管理采用分代的策略。

1）年轻代(Young Gen)：年轻代主要存放新创建的对象，内存大小相对会比较小，垃圾回收会比较频繁。年轻代分成1个Eden Space和**2个Suvivor Space（命名为A和B）**。当对象在堆**创建时，将进入年轻代的Eden Space**。垃圾回收器进行垃圾回收时，扫描Eden Space和A Suvivor Space，如果对象仍然存活，则复制到B Suvivor Space，如果B Suvivor Space已经满，则复制到Old Gen。同时，在扫描Suvivor Space时，如果对象已经经过了几次的扫描仍然存活，JVM认为其为一个持久化对象，则将其移到Old Gen。**扫描完毕后，JVM将Eden Space和A Suvivor Space清空**，**然后交换A和B的角色**（即下次垃圾回收时会扫描Eden Space和BSuvivor Space。这么做主要是为了**减少内存碎片**的产生。

我们可以看到：Young Gen垃圾回收时，采用将存活对象复制到到空的Suvivor Space的方式来确保尽量不存在内存碎片，采用空间换时间的方式来加速内存中不再被持有的对象尽快能够得到回收。
2）年老代(Tenured Gen)：年老代主要存放JVM认为生命周期比较长的对象（经过几次的Young Gen的垃圾回收后仍然存在），内存大小相对会比较大，垃圾回收也相对没有那么频繁（譬如可能几个小时一次）。年老代主要采用压缩的方式来避免内存碎片（将存活对象移动到内存片的一边，也就是内存整理）。当然，有些垃圾回收器（譬如CMS垃圾回收器）出于效率的原因，可能会不进行压缩。
3）持久代(Perm Gen)：持久代主要存放类定义、字节码和常量等很少会变更的信息