# MySQL 优化



#### 单表优化

![img](https://img2020.cnblogs.com/blog/466603/202006/466603-20200602075207585-1546331135.png)

1. 减少存储空间，尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED

2. 使用枚举或整数代替字符串类型，约定规则，比如使用 tinyint类型的 1 表示男 0 代表女
3. 尽量使用TIMESTAMP（4 字节，范围'1970-01-01 00:00:01.000000' to '2038-01-19 03:14:07.999999'，而且是以`utc`的格式储存， 它会自动检索当前时区并进行转换，存进去的是`NULL`，`timestamp`会自动储存当前时间，更改时区会自动改变）而非DATETIME（8 字节，范围 '1000-01-01 00:00:00.000000' to '9999-12-31 23:59:59.999999'，不会进行时区的检索，存进去的是`NULL` `datetime`会储存`NULL`）
4. 单表不要有太多字段，建议在20以内，服务器层和存储引擎层之间是通过行缓存格式拷贝数据
5. 避免使用NULL字段，很难查询优化且占用额外索引空间



#### 索引

1. 考虑在**WHERE和ORDER B**Y命令上涉及的列建立索引
2. **EXPLAIN**来查看是否用了索引还是全表扫描
3. **避免在WHERE子句中对字段进行NULL值判断**，否则将导致引擎放弃使用索引而进行全表扫描
4. 值分布很稀少的字段不适合建索引，例如"性别"这种只有两三个值的字段
5. 字符字段只建**前缀索引**
6. 字符字段最好不要做主键
7. **不用外键**，由程序保证约束
8. **尽量不用UNIQUE**，由程序保证约束
9. 使用**多列索引时主意顺序和查询条件保持一致**，同时删除不必要的单列索引



#### 查询

1. 开启**慢查询日志**来找出较慢的SQL
2. **不做列运算**：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，查询时要尽可能将**操作移至等号右边**
3. sql语句尽可能**简单**
4. **不用SELECT ***
5. **OR改写成IN**：OR的效率是n级别，IN的效率是log(n)级别，**in的个数建议控制在200以内**
6. **不用函数和触发器**，在应用程序实现
7. **避免%xxx式查询**和在WHERE子句中使用**!=或<>**操作符，这会导致全表扫描
8. **少用JOIN**
9. 对于**连续数值，使用BETWEEN不用IN**：SELECT id FROM t WHERE num BETWEEN 1 AND 5
10. 不要拿全表脱裤查询，要使用**LIMIT来分页**



#### MyISAM

1. **不支持行锁**，读取时对需要读到的所有表加锁，写入时则对表加排它锁
2. **不支持事务**
3. **不支持外键**
4. 不支持崩溃后的安全恢复, **不能安全恢复**
5. 支持BLOB和TEXT的前500个字符索引，**支持全文索引**
6. **支持延迟更新索引**，极大提升写入性能
7. **支持压缩表**，极大减少磁盘空间占用，如**日志系统**使用（只有 insert 和 select）



#### InnoDB

1. **支持行锁**，采用**MVCC**(多版本并发机制)来支持高并发
2. 支持事务，支持外键，支持崩溃后的安全恢复
3. 不支持全文索引
4. MyISAM适合SELECT密集型的表，而InnoDB适合INSERT和UPDATE密集型的表



#### 表分区

1. 用户的SQL语句是需要针对分区表做优化，**SQL条件中要带上分区条件的列，从而使查询定位到少量的分区**上，否则就会扫描全部分区
2. 通过**EXPLAIN PARTITIONS来查看某条SQL语句会落在那些分区上**，从而进行SQL优化
3. 可以让单表存储更多的数据，**部分查询能够从查询条件确定只落在少数分区上，速度会很快上（类似 Hash 桶）**，速度会很快
4. 一个表最多只能有1024个分区
5. 分区表无法使用外键约束
6. NULL值会使分区过滤无效
7. 分区类型
   1. **RANGE分区：**基于属于一个**给定连续区间的列值**，把多行分配给分区
   2. **HASH分区：**基于**用户定义的表达式的返回值来进行选择的分区**，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式
   3. **KEY分区：**类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值
   4. 最适合的场景数据的时间序列性比较强，则可以**按时间来分区**

