# 高性能索引策略



#### 独立的列

概述：索引列不能是表达式的一部分，也不能是函数的参数，因为 MySQL 无法解析这个表达式



#### 前缀索引

1. 索引从左开始的部分字符、节约空间、提高索引效率
2. blob、text 及很长的 varchar必须使用前缀索引
3. 前缀基数应该接近于完整列的基数
4. select count(*) as count, left(col, m) as prefix from table group by prefix order by count desc limit 10, 查询 col 列前m个字符出现的次数
5. 计算合适的前缀长度，select count(distinct col)/count(*) from table 得到前缀**选择性系数**，select count(distinct left(col, m))/count(*) from table,不断调整 m的值（前缀长度），直到该比值接近前缀选择性系数
6. 创建前缀索引：alter table table_name add key (col(m));
7. 确定：前缀索引无法order by 和 group by



#### 后缀索引

1. MySQL 原生不支持
2. 实例：查询某个域名的电子邮件
3. 解决方案：电子邮件url 字符串反转后存储



#### 多列索引

1. 老版本MySQL不支持多列索引，or 使用 union all 才能优化
2. 新版本支持多列索引
3. 少用多列索引
4. 前缀原则，创建索引索引列的顺序，**选择性最高的列放在最前面**（列重复字段小的：比如账单表中销售员 ID 和客户 ID，肯定销售员 ID 重复多，那么索引顺序就是客户当前）



#### 索引顺序

1. 最左列进行排序
2. **选择性最高的列放在最前面**，这里指的不是选择性系数高的，而是指select sum(col1),sum(col2) from table where col1=x and col2=y 中 sum 更小的列，能够最先定位到最小的范围再筛选。
3. 注意管理员用户这个特殊情况，他与所有用户都有关系，在某些表中重复率极高，及其影响性能



#### 聚簇索引

1. 存储了索引和数据行
2. 一个表只能有一个聚簇索引
3. 叶子节点包含全部数据、中间节点只含有索引列
4. InnoDB 将主键作为聚簇索引
5. 优点：按列聚集数据、数据访问快
6. 缺点：需要按照主键顺序插入、更新聚簇索引代价高
7. 二级索引：叶子节点不含数据行，而是含有引用列的主键，二级索引访问需要使用两次索引，可以使用 自适应哈希索引优化
8. 避免随机的（比如 UUID）作为聚簇索引



#### 覆盖索引

1. 一个**索引包含所需查询的字段值**，就不需要在读取数据行了
2. 实例： select col1 from table where col1=m
3. 望文生义：索引覆盖了查询的字段值
4. 哈希、全文、空间索引不存储索引值不能使用覆盖索引
5. 查询所有的列会导致没有任何索引能够覆盖这个查询
6. like 不能覆盖索引，因为是所有不包含完整的所需字段值
7. MySQL5.5版本及之前的数据过滤是先将数据表从存储引擎拉到服务器层，在根据条件过滤

