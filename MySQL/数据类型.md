# 数据类型



#### 整数类型

1. 4 种，分别占 1、2、3、4 字节，类似 java4 中整数类型
2. 数据范围：内 -2 的 N-1 次方到 2 的N-1次方-1，无符号就是 0 到 2 的 N 次方-1
3. MySQL 整数计算使用 bigint



#### 实数类型

1. 带有小数部分的数字
2. decimal（18，9）小数点前后各存储 9 个数字，分别占用 4 个字节，小数点占用一个字节
3. 计算中 decimal 会转化成 double
4. 优化：转为 bigint,例如要求精度为保留 4 位小数，那么就约定基础值乘以 10000，客户端显示时在除以 10000，避免浮点数计算精度问题和计算代价过高问题



#### 字符串类型

1. varchar
   1. 可变长,末尾保留空格
   2. 长度在 0-255 之间需要 1 个字节存储字符串长度，大于 255 需要 2 个字节存储长度，例如 varchar(10)全存储 ASCII 码最大占用 11 个字节，varchar(1000)存储 ASCII 码最大占用 1002个字节
   3. 适用场景：字符串最大长度比平均长度大很多，就是字段长度参差不齐；列更新少，碎片不是问题；
   4. InnoDB 会将很大的varchar 转为blob
   5. 不要对长度较长的 varchar 执行 order by
2. char
   1. 定长，末尾不保留空格
   2. 适用场景：存储很短的字段，列所有制的长度接近同一个长度，例如char非常适合存储密码 MD5 值，列值经常变化（定长不容易产生碎片）
   3. 字符串存储长度不是字节数，而是字符数，字节数=字符类型分别乘以对应字符集中设定的字节数之和



#### BLOB 和 text

1. 存储很大字符串设计的字符串数据类型，分别使用二进制和字符方式存储
2. blob没有排序规则和字符集，text 有排序规则和字符集，排序针对前面一小部分字符，不能对全部长度的字符串进行索引



#### 标识列

1. 避免使用字符串作为标识列
2. 最好使用递增的整型
3. 使用 UUID，移除 “—”分隔符，用unhex()转化为16 字节的数字，使用 binary[16]存储，查询时使用 hex()函数换位 16 进制



#### IP 存储优化

IP4 本质是 32 位无符号整数

使用INET_ATON AND INET_NTOA 函数转化小数点分割成四段的 IP 和 32 位 IP